{"backend_state":"init","connection_file":"/tmp/xdg-runtime-user/jupyter/kernel-2bb4b4ff-8414-48a8-8d5a-52c0b7986281.json","kernel":"sage-9.1","kernel_error":"","kernel_state":"idle","kernel_usage":{"cpu":0,"memory":0},"metadata":{"language_info":{"codemirror_mode":{"name":"ipython","version":3},"file_extension":".py","mimetype":"text/x-python","name":"python","nbconvert_exporter":"python","pygments_lexer":"ipython3","version":"3.7.3"}},"trust":true,"type":"settings"}
{"cell_type":"code","exec_count":0,"id":"0a9473","input":"# (1.5)\n# Define our cipher alphabet as all capital English letters\n\nalph = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n\n# Start with an empty string of plaintext\n\nplaintext = ''\n\n# Input our ciphertext and key\n\nciphertext = 'DOFCOMWUYMUL'\nkey = 20\n\n# Edit the code below to remove all references to 'D'\n\nfor ciphertext_letter in ciphertext:\n    ciphertext_number = alph.find(ciphertext_letter)\n    plaintext_number = Mod(ciphertext_number - 20, 26)\n    plaintext_letter = alph[plaintext_number]\n    plaintext += plaintext_letter\nprint(plaintext)","pos":28,"type":"cell"}
{"cell_type":"code","exec_count":0,"id":"20987d","input":"alph(plaintext_number)","pos":16,"type":"cell"}
{"cell_type":"code","exec_count":0,"id":"88831b","input":"# (1.5) \nciphertext_number = alph.find(ciphertext_letter)\nplaintext_number = Mod(ciphertext_number - key, 26)\nplaintext_letter = alph(plaintext_number)\nplaintext += plaintext_letter","pos":22,"type":"cell"}
{"cell_type":"code","exec_count":0,"id":"8a50cd","input":"# (1.3) The code below will convert a plaintext number to a plaintext letter.\n\nplaintext_letter = alph(plaintext_number)","pos":18,"type":"cell"}
{"cell_type":"code","exec_count":0,"id":"b003a7","input":"# (1.2) Once you edit the code below, it should decrypt instead of encrypt.\n\n# 2. To get a ciphertext number, shift the plaintext number up by the key, looping around so that, for example, Z is replaced with C when the key is 3. In other words, we're taking the plaintext number plus the key, mod 26, to get the ciphertext number. \nplaintext_number = Mod(ciphertext_number - key, 26)","pos":14,"type":"cell"}
{"cell_type":"code","exec_count":0,"id":"bda7b5","input":"# (1.4) Edit this code so that it appends plaintext_letter to plaintext\n\nplaintext += plaintext_letter","pos":20,"type":"cell"}
{"cell_type":"code","exec_count":0,"id":"d8f3c0","input":"# Define our cipher alphabet as all capital English letters\n\nalph = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n\n# Start with an empty string of ciphertext\n\nciphertext = ''\n\n# Carry out the encryption steps\n\n# 1. Convert the plaintext letter to a plaintext number.\n\nplaintext_number = alph.find(letter)\n\n# 2. To get a ciphertext number, shift the plaintext number up by the key, looping around so that, for example, Z is replaced with C when the key is 3. In other words, we're taking the plaintext number plus the key, mod 26, to get the ciphertext number. \n\nciphertext_number = Mod(plaintext_number + key, 26)\n\n# 3. Convert the ciphertext number to a ciphertext letter.\n\nciphertext_letter = alph[ciphertext_number]\n\n# 4. Append that letter to our output ciphertext.\n\nciphertext += ciphertext_letter","pos":4,"type":"cell"}
{"cell_type":"code","exec_count":1,"id":"6ae0a3","input":"# (1.6)\n# Define our cipher alphabet as all capital English letters\n\nalph = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n\n# Start with an empty string of plaintext\n\nplaintext = ''\n\n# Input our ciphertext and key\n\nciphertext = 'DOFCOMWUYMUL'\nkey = 20\n\n# Edit the code below to remove all references to 'D'\n\nfor ciphertext_letter in ciphertext:\n    ciphertext_number = alph.find(ciphertext_letter)\n    plaintext_number = Mod(ciphertext_number - 20, 26)\n    plaintext_letter = alph[plaintext_number]\n    plaintext += plaintext_letter","pos":25,"type":"cell"}
{"cell_type":"code","exec_count":3,"id":"69b24f","input":"alph.find('D')","output":{"0":{"data":{"text/plain":"3"},"exec_count":3,"output_type":"execute_result"}},"pos":6,"type":"cell"}
{"cell_type":"code","exec_count":3,"id":"b5ba11","input":"# (1.6)\n# Define our cipher alphabet as all capital English letters\n\nalph = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n\nplaintext = ''\n\n# Edit the code below to remove all references to specific ciphertext or keys\n\nfor letter in ciphertext:\n    ciphertext_number = alph.find(letter)\n    plaintext_number = Mod(ciphertext_number - key, 26)\n    plaintext_letter = alph[plaintext_number]\n    plaintext += plaintext_letter\n\nprint(plaintext)","output":{"0":{"name":"stdout","output_type":"stream","text":"JULIUSCAESAR\n"}},"pos":30,"type":"cell"}
{"cell_type":"code","exec_count":3,"id":"ea3885","input":"def ShiftDecryptX(ciphertext, key):\n    alph = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ~?!'\n    plaintext = ''\n    for letter in ciphertext:\n        ciphertext_number = alph.find(letter)\n        plaintext_number = Mod(ciphertext_number - key, 29)\n        plaintext_letter = alph[plaintext_number]\n        plaintext += plaintext_letter\n    print(plaintext)","pos":39,"type":"cell"}
{"cell_type":"code","exec_count":4,"id":"49e72f","input":"# Write the code to decrypt your encrypted message here.\n\n# Answer may vary. Example:\nShiftDecryptX('KMLICW', 27)","output":{"0":{"name":"stdout","output_type":"stream","text":"MONKEY\n"}},"pos":41,"type":"cell"}
{"cell_type":"code","exec_count":4,"id":"c1ca81","input":"# Define our cipher alphabet as all capital English letters\n\nalph = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n\n# Begin with an empty string of plaintext\n\nplaintext = ''\n\n# Input our ciphertext letter and key\n\nciphertext_letter = 'D'\nkey = 20\n\n# Your code goes below\n\nalph.find(ciphertext_letter)","output":{"0":{"data":{"text/plain":"3"},"exec_count":4,"output_type":"execute_result"}},"pos":8,"type":"cell"}
{"cell_type":"code","exec_count":4,"id":"e94152","input":"# (1.7)\ndef ShiftDecrypt(ciphertext, key):\n    alph = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n    plaintext = ''\n    for letter in ciphertext:\n        ciphertext_number = alph.find(letter)\n        plaintext_number = Mod(ciphertext_number - key, 26)\n        plaintext_letter = alph[plaintext_number]\n        plaintext += plaintext_letter\n    print(plaintext)","pos":32,"type":"cell"}
{"cell_type":"code","exec_count":5,"id":"c2e000","input":"# (1.1) This step converts a ciphertext letter to a ciphertext number and stores the number\n\nciphertext_number = alph.find(ciphertext_letter)","pos":10,"type":"cell"}
{"cell_type":"code","exec_count":6,"id":"606654","input":"ShiftDecrypt(\"SPMLSPILYAFHUKAOLWBYZBPAVMOHWWPULZZ\",7)","output":{"0":{"name":"stdout","output_type":"stream","text":"LIFELIBERTYANDTHEPURSUITOFHAPPINESS\n"}},"pos":34,"type":"cell"}
{"cell_type":"code","exec_count":7,"id":"3e5dba","input":"ShiftDecrypt(\"QPUBUPFT\",27)","output":{"0":{"name":"stdout","output_type":"stream","text":"POTATOES\n"}},"pos":36,"type":"cell"}
{"cell_type":"markdown","id":"00011d","input":"Now, just as before, we want to assign our new plaintext letter to the variable `plaintext_letter`. In order to do so, copy-paste your code from the box above after the equals sign below.","pos":17,"type":"cell"}
{"cell_type":"markdown","id":"097bc1","input":"Great! If your code worked, you should end up with the number $3$. Below, copy-paste your line of code from above after the equals sign in order to assign this $3$ to the variable `ciphertext_number`.","pos":9,"type":"cell"}
{"cell_type":"markdown","id":"0f576d","input":"3. Finally, test your new function by first using your beefed-up `ShiftEncrypt` function from Exercise 2 of that assignment to encrypt a message. Then, in the box below, input the encrypted message and run your beefed-up `ShiftDecrypt` function from Exercise 2 above to decrypt it. Did you get the plaintext you started with? Why or why not?","pos":40,"type":"cell"}
{"cell_type":"markdown","id":"122af4","input":"### Let's do it!\n\nAre you back? Great! Let's try to write a `for` loop that decrypts the entire message 'DOFCOMWUYMUL', which was encrypted with the key $k=20$. \n\nOur goal is to replace the letter 'D' in our code above with a *variable*. Like in algebra, variables can take on many values. So far, we've already seen the variables ``alph``, ``plaintext``, ``key``, and ``ciphertext``. They are placeholders for letters or numbers that can be assigned values, just like the equation $x=3$ assigns the variable $x$ the value $3$.\n\nBelow, I've started you off with the beginning of a `for` loop and the code we used to shift 'D' back by $20$. Edit that code by deleting all references to 'D' and replacing them with the variable ``letter``. Then the `for` loop will cycle through all the letters in the message 'DOFCOMWUYMUL' and shift *all* of them back by $20$. Then click Run on your edited chunk and see what happens. Once you click Run and observe the results, read the text below the chunk.","pos":24,"type":"cell"}
{"cell_type":"markdown","id":"1ca13f","input":"Now, what do we want to do to this number in order to decrypt it? In words (not Sage code), describe this step in the box below. ","pos":11,"type":"cell"}
{"cell_type":"markdown","id":"20e00f","input":"*Convert the ciphertext letter to a ciphertext number.*","pos":2,"type":"cell"}
{"cell_type":"markdown","id":"2a829c","input":"### Undoing step $2$\n\nWe now want to undo step $2$ of the process above. Step $2$ took our plaintext number and added the key, mod $26$, to get our ciphertext number.\n\nNow, we're starting with a ciphertext number and want to go back to a plaintext number. Below, I've recopied the code for step $2$ of the encryption process. Alter the code in order to make it *decrypt* instead of *encrypt*. **Hint**: take the modular arithmetic equation we used to decrypt shift ciphers in class, $P\\equiv C-k\\mod{26}$, and replace $P$ with `plaintext_number`, $C$ with `ciphertext_number`, and $k$ with `key`.","pos":13,"type":"cell"}
{"cell_type":"markdown","id":"4509e5","input":"### Time to print!","pos":26,"type":"cell"}
{"cell_type":"markdown","id":"461018","input":"Now, however, we're starting with ciphertext, given unsurprisingly by the variable `ciphertext`, and we want to *end up with* plaintext. Just like we did above, we'll start with an empty string of plaintext using the command\n\n``plaintext = ''``\n\n(don't worry too much about how this works).\n\nAbove, step $3$ converted our ciphertext numbers to ciphertext letters using the `alph` command. Step $1$ converted letters to numbers using the `alph.find` command. Which command, `alph` or `alph.find`, do we want to use to convert our ciphertext letters to numbers? Write your answer below.","pos":5,"type":"cell"}
{"cell_type":"markdown","id":"466404","input":"# Rubric\n\n- 50 points: student's `ShiftDecrypt` function correctly decrypts `SPMLSPILYAFHUKAOLWBYZBPAVMOHWWPULZZ` as `LIFELIBERTYANDTHEPURSUITOFHAPPINESS`.\n- 10 points: in Exercise 1, students correctly decrypt with a shift of $27$ and justify why decrypting with a $-27$ shift is equivalent to decrypting with a $-1$ shift modulo $26$.\n- 40 points: student verifies that running their extended-alphabet `ShiftEncrypt` function on some plaintext of their choice, then running their extended-alphabet `ShiftDecrypt` function on the resulting ciphertext, gives back the initial plaintext.","pos":0,"type":"cell"}
{"cell_type":"markdown","id":"52d1ad","input":"*Shift it back by 20, mod 26*","pos":12,"type":"cell"}
{"cell_type":"markdown","id":"5ab92c","input":"The chunk above should have again spit out the plaintext corresponding to the ciphertext 'DOFCOMWUYMUL'. This is because we've already told Python in the previous section that `ciphertext` is a placeholder for the text 'DOFCOMWUYMUL' and `key` is a placeholder for the number $20$. What if we want to decrypt a different message using a different key? Do we have to write all this code out again, changing the values of the variables `ciphertext` and `key`? Thankfully, no!\n\nTo save us from having to write out all this code anytime we want to decrypt a message with a shift cipher, we'll wrap everything up in a **function**. Then, if we want to decrypt the message 'AJTQETA' using the key $7$, all we'll have to write is\n\n``ShiftDecrypt('AJTQETA',7)``\n\nJust like a mathematical function like $f(x)=3x+2$, Sage functions have *inputs* or *independent variables* (like $x$ in the example $f(x)=3x+2$) and *outputs* or *dependent variables* (like the $3x+2$). For every input $x$ (for example $x=3$), the function outputs $3$ times that input plus $2$. So for the input $3$, the function $f(x)$ spits out $11$.\n\nThe function we're dealing with doesn't just have one input, though, it has two: the ciphertext and the key. One of those inputs (the ciphertext) is a word and the other is a number.\n\nRemember from Codecademy that, to start defining a Sage or Python function, you have to start with a `def` command. I'll set the `def` command up for you below; try copy-pasting your code from the chunk above underneath the `def` command. Remember that everything the function does has to be tabbed over once, and everything in your `for` loop has to be tabbed over once more, so the stuff inside your `for` loop is *double*-tabbed! I\"ll start you off by defining the alphabet and the empty string called `plaintext` like we did above.","pos":31,"type":"cell"}
{"cell_type":"markdown","id":"610aa5","input":"Now, mimic my code in the 'AJTQETA' example above and use your function to decrypt the phrase 'SPMLSPILYAFHUKAOLWBYZBPAVMOHWWPULZZ' with a shift of $7$. Yes, it was a lot of work to write the function, but now that we have the function, decryption is so much easier than it would be by hand! (**Hint**: you probably want to copy/paste the ciphertext.)","pos":33,"type":"cell"}
{"cell_type":"markdown","id":"623ae6","input":"Decrypting with a key of $27$ is the same as decrypting with a key of $1$. This is because $27\\equiv 1\\mod{26}$.","pos":37,"type":"cell"}
{"cell_type":"markdown","id":"764c1f","input":"Now, say we're given the ciphertext letter 'D'. Below, I'll start with an empty string of plaintext, then assign the variable `ciphertext_letter` to the letter 'D' and the variable `key` to the value $20$ (don't worry too much about how this works). Below my code, write the code to convert the variable `ciphertext_letter` to a number using the command you wrote above, either `alph` or `alph.find`. Then run your code to see if it works and talk to someone if it doesn't.","pos":7,"type":"cell"}
{"cell_type":"markdown","id":"7b4745","input":"If you edited and ran the code above correctly, *nothing should have happened*. Why not? Well, we didn't actually tell Sage to *show* us the ciphertext.\n\nThis might sound silly. Computer programs and programming languages are very smart in some ways and very dumb in others. To a human, it'd be obvious that, if we asked them to decrypt some ciphertext, they should actually tell us what the decrypted message says. To Python, not so much. We have to explicitly ask using the `print` command.\n\nThe `print` command doesn't actually send anything to a printer. It just prints words, numbers, or letters on the screen.\n\nIn our case, we want to print the plaintext, which we've conveniently assigned to the variable `plaintext`. In the code box below, copy-paste your code from chunk (1.5) above. Then, outside the tabbed section, write the command to print the variable `plaintext`. Then run the chunk and see what happens. You should see the ciphertext resulting from decrypting the word 'DOFCOMWUYMUL' with the key $20$.","pos":27,"type":"cell"}
{"cell_type":"markdown","id":"8a542c","input":"### Undoing step $1$\n\nGreat! We've undone steps $3$ and $2$; now to undo step $1$. When we were encrypting messages, step $1$ was to convert a plaintext letter to a plaintext number. However, when decrypting and after undoing steps $3$ and $2$, we end up with a plaintext *number*. How do we convert it to a plaintext letter? Below, write the code to convert the variable `plaintext_number` from a number to a letter. **Hint**: you're using either `alph` or `alph.find`.","pos":15,"type":"cell"}
{"cell_type":"markdown","id":"8e653a","input":"### Secret extra step: appending our letter to the output plaintext\n\nWe're not quite done yet! Just like we appended our ciphertext letters to the output ciphertext in step 4 of the encryption process, we have to append our output *plain*text letters to the output *plain*text in step 4 of the *de*cryption process.\n\nThe code below was used in the last module to append the variable `ciphertext_letter` to the variable `ciphertext`. Below, edit the code so that it appends the variable `plaintext_letter` to the variable `plaintext` instead.","pos":19,"type":"cell"}
{"cell_type":"markdown","id":"c44303","input":"# Decrypting Shift Ciphers with Known Key\n\n## Decrypting a single letter\n\nIf we know the key, decrypting a letter that was encrypted using a shift cipher just requires undoing the encryption steps. In the last module, we performed the following four steps to encrypt a letter using a shift cipher:\n\n1. Convert the plaintext letter to a plaintext number.\n2. To get a ciphertext number, shift the plaintext number up by the key, looping around so that, for example, Z is replaced with C when the key is $3$. In other words, we're taking the plaintext number plus the key, mod $26$, to get the ciphertext number. \n3. Convert the ciphertext number to a ciphertext letter. \n4. Append that letter to our output ciphertext.\n\nIn order to *undo* this process, we'll have to undo each step *backwards*. If you were given a cipheretxt letter (say 'D') and a key (say $20$), what would be your first step if you were trying to decrypt the letter? In words (not Sage code), describe this step in the box below. **Hint**: for time and accuracy reasons, you probably don't want to recite the alphabet backwards by $20$ letters.","pos":1,"type":"cell"}
{"cell_type":"markdown","id":"cf40b2","input":"### Undoing step $3$\n\nEffectively, we're *undoing* step 3 first. Here is the code we used to encrypt a letter (given by the variable `plaintext`) in our previous Sage module. Note that, just like with encryption, we first want to define a cipher alphabet: in this case, all capital English letters.","pos":3,"type":"cell"}
{"cell_type":"markdown","id":"d7f80a","input":"Here, describe whether you got the plaintext you started with and why or why not.","pos":42,"type":"cell"}
{"cell_type":"markdown","id":"e63eb1","input":"### Putting it all together\n\nAwesome! The code we've written so far takes the ciphertext letter 'D', assigns it to the variable `ciphertext_letter`, and does the following:\n\n1. Converts the ciphertext letter to a ciphertext number and stores this number in the variable `ciphertext_number`.\n2. Subtracts the key from the ciphertext number and stores the result in the variable `plaintext_number`.\n3. Converts the plaintext number to a plaintext letter and stores this letter in the variable `plaintext_letter`.\n4. Appends the `plaintext_letter` to the output `plaintext`.\n\nIn the code chunk below, copy the lines of code you wrote marked (1.1), (1.2), (1.3), and (1.4) all in order. This code contains the whole decryption process for a single ciphertext letter!","pos":21,"type":"cell"}
{"cell_type":"markdown","id":"ea0a40","input":"2. Copy and paste the function above (changing its name) and try to change the code so that it decrypts using *the same* larger alphabet you used in the ShiftEncrypt module. Be sure to adjust the modulus accordingly!","pos":38,"type":"cell"}
{"cell_type":"markdown","id":"f6f5a0","input":"## Exercises\n\nNow that you have a function, try answering the following:\n\n1. What do you think happens if you try to *decrypt* use a key that's larger than your alphabet? Try decrypting the message 'QPUBUPFT' with a key of 27 and see! Is the result what you expected? Can you do some modular arithmetic to show why this is the case?","pos":35,"type":"cell"}
{"cell_type":"markdown","id":"f93088","input":"## Decrypting whole words\n\nGreat! You've managed to shift one ciphertext letter to a plaintext letter. However, in order to decrypt messages, we're going to need to shift *multiple* ciphertext letters at once. To do this, we need the magic of ``for`` loops.\n\nYou've already seen ``for`` loops in Codecademy and in the previous module. Basically, the idea is that we want to repeat a task, like shifting letters, over and over again. How many times do we want to repeat the task? Well, once for every letter in our ciphertext. The code to start this ``for`` loop is\n\n``for ciphertext_letter in ciphertext:``\n\nIf you type the above line of code into a code chunk and hit enter, the next line will be tabbed over. Python uses whitespace as a way of managing what's inside a `for` loop and what's not. **Every bit of code you write that's tabbed over under a `for` loop will be run for every single letter of your ciphertext.** \n\nSo what should we write tabbed over inside this `for` loop? I'm glad you asked. Once you've reached this point, try to help others around you until we're all at this point, and we'll talk as a class about what goes inside our `for` loop.","pos":23,"type":"cell"}
{"cell_type":"markdown","id":"faa391","input":"## Creating a Function\n\nNow, when shift ciphers are used in the real world, the ciphertext is almost certain not to be 'DOFCOMWUYMUL', and the key may not be $20$. Instead of this specific ciphertext and key, we want to allow ourselves the freedom to *define* whatever ciphertext and key we want. In other words, we want ``ciphertext`` and ``key`` to be *inputs* to a function.\n\nWe can almost exactly recycle our code from above, where we decrypted 'DOFCOMWUYMUL' with a shift of $20$. However, we'll need to replace any references to specific ciphertext with the variable `ciphertext` and any references to specific numerical keys with the variable `key`.\n\nIn the code box below, remove all references to the ciphertext 'DOFCOMWUYMUL', leaving only references to the variable `ciphertext`, and all references to the number $20$, leaving only references to the variable `key`. Then try running the chunk. Once you've run the chunk and observed what happens, read the text below.","pos":29,"type":"cell"}
{"id":0,"time":1632893556215,"type":"user"}
{"last_load":1632924374632,"type":"file"}