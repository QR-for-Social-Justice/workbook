{"backend_state":"init","connection_file":"/tmp/xdg-runtime-user/jupyter/kernel-797f1d28-7c11-40a9-b3fd-3882bc5be362.json","kernel":"python3","kernel_error":"","kernel_state":"idle","kernel_usage":{"cpu":0,"memory":0},"metadata":{"language_info":{"codemirror_mode":{"name":"ipython","version":3},"file_extension":".py","mimetype":"text/x-python","name":"python","nbconvert_exporter":"python","pygments_lexer":"ipython3","version":"3.7.4"}},"trust":true,"type":"settings"}
{"cell_type":"code","end":1647444501884,"exec_count":1,"id":"d0bf30","input":"import json\nimport re","kernel":"python3","no_halt":true,"pos":0,"start":1647444501878,"state":"done","type":"cell"}
{"cell_type":"code","end":1647444501896,"exec_count":2,"id":"6961b2","input":"# Note that you need to move any external files (images usually) either to the local director of this script or two a url\n# and update your Jupyter notebook with the urls.\n\n# A bug that I have not fixed is if a ordered or unordered list terminates as the last line in a cell then the last\n# list item is closed without closing the enclosed paragraph (which is really annoying). \n# The simple fix is to add an end of line in the Jupyter notebook anytime one of these environments ends a cell.","kernel":"python3","no_halt":true,"pos":1,"start":1647444501889,"state":"done","type":"cell"}
{"cell_type":"code","end":1647444501912,"exec_count":3,"id":"1d4c4c","input":"# Read in the notebook file\n\njson_file = open('ShiftEncrypt_rubric.ipynb')\ndata = json.load(json_file)","kernel":"python3","no_halt":true,"pos":2,"start":1647444501901,"state":"done","type":"cell"}
{"cell_type":"code","end":1647444501932,"exec_count":4,"id":"639907","input":"# cells is an array of the cell data from the notebook\n\ncells = data['cells']","kernel":"python3","no_halt":true,"pos":3,"start":1647444501918,"state":"done","type":"cell"}
{"cell_type":"code","end":1647444501974,"exec_count":5,"id":"3dbb19","input":"current = 0","kernel":"python3","no_halt":true,"pos":4,"start":1647444501963,"state":"done","type":"cell"}
{"cell_type":"code","end":1647444502019,"exec_count":6,"id":"26e340","input":"def new_section(p, current, lev):\n    out = ''\n    if current == 1:\n        out += '<section>\\n <title>'\n        out += p[lev:]\n        out += '</title>'\n    elif current == 2:\n        out += '<subsection>\\n <title>'\n        out += p[lev:]\n        out += '</title>'\n    elif current == 3:\n        out += '<subsubsection>\\n <title>'\n        out += p[lev:]\n        out += '</title>'\n    elif current == 4:\n        out += '<paragraphs>\\n <title>'\n        out += p[lev:]\n        out += '</title>'\n        \n    return out","kernel":"python3","no_halt":true,"pos":5,"start":1647444501981,"state":"done","type":"cell"}
{"cell_type":"code","end":1647444502037,"exec_count":7,"id":"387868","input":"def close_section(current):\n    out = ''\n    \n    if current == 1:\n        out += '\\n</section>\\n'\n    elif current == 2:\n        out += '\\n</subsection>\\n'\n    elif current == 3:\n        out += '\\n</subsubsection>\\n'\n    elif current == 4:\n        out += '\\n</paragraphs>\\n'\n    \n    return out","kernel":"python3","no_halt":true,"pos":6,"start":1647444502026,"state":"done","type":"cell"}
{"cell_type":"code","end":1647444502047,"exec_count":8,"id":"4c8786","input":"def remove_colon(p):\n    \n    if p[-2]==':':\n        return p[:-2]+p[-1]\n    else:\n        return p\n    ","kernel":"python3","no_halt":true,"pos":7,"start":1647444502042,"state":"done","type":"cell"}
{"cell_type":"code","end":1647444502064,"exec_count":9,"id":"a71208","input":"def is_quote_envr(p, envr):\n    \n    out = ''\n    \n    if p[0]=='>' and not '>' in envr:     # If this is the start of a quote block, use the first line as title\n        envr += ['>']\n        if ':' in p:\n            p = remove_colon(p)\n        out += '<blockquote><paragraphs><title>'+p[1:-1]+'</title>\\n'\n        p = ''\n    elif p[0]=='>':   # If this is the middle of the quote block, return a new p\n        p = p[1:].lstrip()\n    elif envr[-1]=='>':  # If this is the line after the end of a quote block, adjust envr and close quote block\n        envr = envr[:-1]\n        out += '</paragraphs></blockquote>\\n'\n        \n    return out, p, envr","kernel":"python3","no_halt":true,"pos":8,"start":1647444502052,"state":"done","type":"cell"}
{"cell_type":"code","end":1647444502109,"exec_count":10,"id":"fc6dda","input":"def is_enumerate_envr(p, envr):\n    \n    out = ''\n    \n    if len(p)<2:\n        pt = 'XX'\n    else:\n        pt = p\n    \n    if str.isdigit(p[0]) and p[1]=='.':   # Are we in an ordered list\n        if not 'enumerate' in envr:         # check if the environment has been set to ordered list\n            envr += ['p', 'enumerate'] \n            out += '<p><ol>\\n'\n\n        temp, envr = read_line_no_enumerate(p[2:], envr)        \n        out += '<li>'+temp+'</li>\\n'\n        p = ''      # Add the item  (need to come back and add the per character scanning here)\n    elif envr[-1]=='enumerate':    # If the Jupyter file is not in an ordered list but envr still is, back out \n                                   # and close.\n        envr = envr[0:-2]\n        out += '</ol></p>\\n'\n        \n    return out, p, envr\n        ","kernel":"python3","no_halt":true,"pos":9,"start":1647444502076,"state":"done","type":"cell"}
{"cell_type":"code","end":1647444502150,"exec_count":11,"id":"0fe404","input":"def is_itemize_envr(p, envr):\n    \n    out = ''\n    \n    if len(p)<2:\n        pt = 'XX'\n    else:\n        pt = p\n    \n    if pt[0:2]=='- ':   # Are we in an unordered list\n        if not 'itemize' in envr:         # check if the environment has been set to unordered list\n            envr += ['p', 'itemize'] \n            out += '<p><ul>\\n'\n            \n        temp, envr = read_line_no_itemize(p[2:], envr)        \n        out += '<li>'+temp+ '</li>\\n'      # Add the item  (need to come back and add the per character scanning here)\n        p = ''\n    elif envr[-1]=='itemize':    # If the Jupyter file is not in an ordered list but envr still is, back out \n                                   # and close.\n        envr = envr[0:-2]\n        out += '</ul></p>\\n'\n        \n    return out, p, envr","kernel":"python3","no_halt":true,"pos":10,"start":1647444502121,"state":"done","type":"cell"}
{"cell_type":"code","end":1647444502196,"exec_count":12,"id":"f125e3","input":"def is_paragraph(p, envr):\n    \n    out = ''\n    \n    if len(p)==0:   # Pad the string if it is less than 1 character -- note less than one character means it has \n                    # been processed. Should we instead skip this function in the call?\n        pt = '\\n'\n    else:\n        pt = p\n    \n    if pt[0]!='\\n' and envr[-1]!='p':  # Check if we should start a new paragraph\n        envr += ['p']\n        out = '<p>'\n    elif (p=='\\n' or p=='') and envr[-1]=='p': # Check if we should close the current paragraph\n        envr = envr[0:-1]\n        out = '</p>'\n        \n    return out, p, envr","kernel":"python3","no_halt":true,"pos":11,"start":1647444502166,"state":"done","type":"cell"}
{"cell_type":"code","end":1647444502270,"exec_count":13,"id":"27df91","input":"def render_link(p):\n    \n    out = ''\n    \n    end1 = p.index(']')\n    end2 = p.index(')')\n    \n    text = p[1:end1]\n    href = p[end1+2:end2]\n    \n    out = '<url href=\"'+href+'\"> '+text+' </url> '\n    p = p[end2+1:]\n    \n    return out, p","kernel":"python3","no_halt":true,"pos":12,"start":1647444502215,"state":"done","type":"cell"}
{"cell_type":"code","end":1647444502506,"exec_count":14,"id":"386a83","input":"def render_em(p):\n    \n    # A note here:  Markdown includes * and ** for italics and then bold. We will translate these in Pretext as the <em> and\n    # <alert> tags resp..\n    \n    out = ''\n    \n    end1 = p.index('*')\n    if p[end1+1]=='*':\n        end2 = p[(end1+2):].index('*')\n        text = p[(end1+2):end2+2]\n        out = '<alert>' + text + '</alert>'\n        p = p[end2+4:]\n    else:\n        end2 = p[(end1+1):].index('*')\n        text = p[end1+1:end2+1]\n        out = '<em>' + text + '</em>'\n        p = p[end2+2:]\n        \n    return out, p","kernel":"python3","no_halt":true,"pos":13,"start":1647444502283,"state":"done","type":"cell"}
{"cell_type":"code","end":1647444502572,"exec_count":15,"id":"410cad","input":"def render_img(p):\n    \n    # The basic issue here is that we have to render the image code all at once as otherwise the quote environment\n    # will catch it when the bracket is closed with '>'\n    \n    out = ''\n    \n    equal = p.index('=')\n    end = p.index('>')\n    if '\"' in p[equal:end]:\n        source_start = p[equal:].index('\"')+equal\n        source_end = p[source_start+1:].index('\"')+source_start+1\n    elif \"'\" in p[equal:end]:\n        source_start = p[equal:].index(\"'\")+equal\n        source_end = p[source_start+1:].index(\"'\")+source_start+1\n    else: \n        print('No quote in image environment.')\n    out = '<image source=' + p[source_start:source_end+1] + ' width=\"60%\"/>'\n    p = p[end+1:]\n    \n    # Note that we are defaulting to a size specification of 60% - you will need to go through and adjust that. \n    # The issue is that Jupyter is using pixel specification and Pretext wants percentage of available width.\n    \n    # Using Figure with empty caption?\n    \n    return out, p","kernel":"python3","no_halt":true,"pos":14,"start":1647444502566,"state":"done","type":"cell"}
{"cell_type":"code","end":1647444502585,"exec_count":16,"id":"25b443","input":"def remove_br(p):\n    \n    # Markdown requires <br> commands for carriage returns. Pretext has other methods (at the moment I'm just using <p>)\n    \n    end = p.index('>')\n    \n    return p[end+1:]","kernel":"python3","no_halt":true,"pos":15,"start":1647444502579,"state":"done","type":"cell"}
{"cell_type":"code","end":1647444502595,"exec_count":17,"id":"500822","input":"def close_envr(envr):\n    \n    out = ''\n    \n    for code in envr[-1::-1]:\n        if code == '':\n            pass\n        elif code == 'p':\n            out += '</p>\\n'\n        elif code == 'enumerate':\n            out += '</ol>\\n'\n        elif code == 'itemize':\n            out += '</ul>\\n'\n        elif code == '>':\n             out += '</paragraphs></blockquote>\\n'            \n        else:\n            print('Environment Code '+code+' Not Recognized')\n            \n    return out","kernel":"python3","no_halt":true,"pos":16,"start":1647444502591,"state":"done","type":"cell"}
{"cell_type":"code","end":1647444502607,"exec_count":18,"id":"47f430","input":"def render_math(p):\n    \n    # For now assuming mathematics is all on one line. Will need to update in the future for formulas\n    # that run over multiple lines.\n    \n    if p[1] == '$':\n        start = 2\n        out = '<me>'\n        close = '</me>'\n    else:\n        start = 1\n        out = '<m>'\n        close = '</m>'\n    \n    end = p[start:].index('$')\n    \n    out += p[start:end+1] + close  # A little bothered by the +1 here...\n    p = p[end+2*start:]\n    \n    return out, p\n    ","kernel":"python3","no_halt":true,"pos":17,"start":1647444502602,"state":"done","type":"cell"}
{"cell_type":"code","end":1647444502666,"exec_count":19,"id":"861191","input":"def read_line_no_enumerate(p, envr):\n    \n    out = ''\n    \n    while p!='': # Basically go through string character by character, though some control expressions are \n                 # handled as multiple characters.\n        \n            # Some nesting of environments is not allowed:  bullet within bullet will not work.\n        \n            # Check for quote environment (assumption for now is that quote environment is \n            # not nested in another envr)\n        \n            temp, p, envr = is_quote_envr(p, envr)\n            out += temp\n            \n            # Check for itemize environment, which could be nested in a quote or enumerate environment (will need\n            # to come back and fix this so the nesting could go the other way).\n            \n            if len(p)>2:\n                if p[0:1]=='- ' or envr[-1]=='itemize':\n                    temp, p, envr = is_itemize_envr(p, envr)\n                    out += temp\n            \n            # Check if we need a paragraph environment - note that enumerate (and later list come with their own)\n            \n            if len(p)>0 or envr[-1]=='p':\n                temp, p, envr = is_paragraph(p, envr)\n                out += temp\n            \n            # Read by characters, looking for links, math environments, and other text markdown\n            \n            if len(p) > 0:\n                if p[0]=='[' and ']' in p:\n                    temp, p = render_link(p)\n                    out += temp\n                elif p[0]=='*':\n                    temp, p = render_em(p)\n                    out += temp\n                elif p[0]=='$':\n                    temp, p = render_math(p)\n                    out += temp\n                elif p[0:4]=='<img':\n                    temp, p = render_img(p)\n                    out += temp\n                else:\n                    out += p[0]\n                    p = p[1:]\n                    \n    return out, envr","kernel":"python3","no_halt":true,"pos":18,"start":1647444502616,"state":"done","type":"cell"}
{"cell_type":"code","end":1647444502686,"exec_count":20,"id":"c8b8c8","input":"def read_line_no_itemize(p, envr):\n    \n    out = ''\n    \n    while p!='': # Basically go through string character by character, though some control expressions are \n                 # handled as multiple characters.\n        \n            # Some nesting of environments is not allowed:  bullet within bullet will not work.\n        \n            # Check for quote environment (assumption for now is that quote environment is \n            # not nested in another envr)\n        \n            temp, p, envr = is_quote_envr(p, envr)\n            out += temp\n        \n            # Assumption for now is that enumerate is not nested in any environment other than quote - will\n            # need to adjust this later.\n            \n            if len(p)>2:        \n                if (str.isdigit(p[0]) and p[1]=='.') or envr[-1]=='enumerate':\n                    temp, p, envr = is_enumerate_envr(p, envr)\n                    out += temp\n            \n            # Check if we need a paragraph environment - note that enumerate (and later list come with their own)\n            \n            if len(p)>0 or envr[-1]=='p':\n                temp, p, envr = is_paragraph(p, envr)\n                out += temp\n            \n            # Read by characters, looking for links, math environments, and other text markdown\n            \n            if len(p) > 0:\n                if p[0]=='[' and ']' in p:\n                    temp, p = render_link(p)\n                    out += temp\n                elif p[0]=='*':\n                    temp, p = render_em(p)\n                    out += temp\n                elif p[0]=='$':\n                    temp, p = render_math(p)\n                    out += temp\n                elif p[0:4]=='<img':\n                    temp, p = render_img(p)\n                    out += temp\n                else:\n                    out += p[0]\n                    p = p[1:]\n                    \n    return out, envr","kernel":"python3","no_halt":true,"pos":19,"start":1647444502677,"state":"done","type":"cell"}
{"cell_type":"code","end":1647444502714,"exec_count":21,"id":"3b0b37","input":"def read_line(p, envr):\n    \n    out = ''\n    \n    while p!='': # Basically go through string character by character, though some control expressions are \n                 # handled as multiple characters.\n        \n            # Some nesting of environments is not allowed:  bullet within bullet will not work.\n        \n            # Check for quote environment (assumption for now is that quote environment is \n            # not nested in another envr)\n        \n            temp, p, envr = is_quote_envr(p, envr)\n            out += temp\n        \n            # Check for enumerate environment, which could be nested in a quote environment (will need to come \n            # back and fix this so the nesting could go the other way).\n        \n            # Assumption for now is that enumerate is not nested in any environment other than quote - will\n            # need to adjust this later.\n      \n            if len(p)>2 or envr[-1]=='enumerate':\n                temp, p, envr = is_enumerate_envr(p, envr)\n                out += temp\n            \n            # Check for itemize environment, which could be nested in a quote or enumerate environment (will need\n            # to come back and fix this so the nesting could go the other way).\n            \n            if len(p)>2 or envr[-1]=='itemize':\n                temp, p, envr = is_itemize_envr(p, envr)\n                out += temp\n            \n            # Check if we need a paragraph environment - note that enumerate (and later list come with their own)\n            \n            if len(p)>0 or 'p' in envr:\n                temp, p, envr = is_paragraph(p, envr)\n                out += temp\n            \n            # Read by characters, looking for links, math environments, and other text markdown\n            \n            if len(p) > 0:\n                if p[0]=='[' and ']' in p:\n                    temp, p = render_link(p)\n                    out += temp\n                elif p[0]=='*':\n                    temp, p = render_em(p)\n                    out += temp\n                elif p[0]=='$':\n                    temp, p = render_math(p)\n                    out += temp\n                elif p[0:4]=='<img':\n                    temp, p = render_img(p)\n                    out += temp\n                else:\n                    out += p[0]\n                    p = p[1:]\n                    \n    return out, envr","kernel":"python3","no_halt":true,"pos":20,"start":1647444502693,"state":"done","type":"cell"}
{"cell_type":"code","end":1647444502729,"exec_count":22,"id":"1beb89","input":"def manipulate_sections(p, current):\n        \n        out = ''\n        \n        lev = p.count('#')  # Check if this line is identifying a section and then compare with current section\n                            # position and adjust.\n        \n        if not lev == 0:\n            while current > lev:\n                out += close_section(current)\n                current += -1\n            if current == lev:\n                out += close_section(current)\n                out += new_section(p, current, lev)\n                p = '\\n'\n            while current < lev-1:\n                current += 1\n                out += new_section('\\n', current, lev)\n            if current == lev-1:\n                current += 1\n                out += new_section(p, current, lev)\n                p = '\\n'\n        \n        return out, p, current","kernel":"python3","no_halt":true,"pos":21,"start":1647444502725,"state":"done","type":"cell"}
{"cell_type":"code","end":1647444502746,"exec_count":23,"id":"d85a41","input":"def read_metadata(cell, current):\n    out = ''\n    temp = ''\n\n    envr = ['']  # Initialize an list to keep track of open environments assumption will be that all \n                   # multiline environments are identified in markdown by the first character of the line.\n                   # quote environment is terminated when the > symbol is dropped.\n                   # enumerate and bullet environments either when the enclosing environment increments or \n                    # at the termination of the block. \n    \n    for p in cell:  # cycle through each line of this cell\n        if p[0]=='#': # Check if we are changing sectioning\n            temp, p, current = manipulate_sections(p, current)\n            out += temp\n    \n        temp, envr = read_line(p, envr)\n        out += temp\n    \n    # at the end of a markdown block close any envr left open\n        \n    out += close_envr(envr)\n    \n    return out, current ","kernel":"python3","no_halt":true,"pos":22,"start":1647444502736,"state":"done","type":"cell"}
{"cell_type":"code","end":1647444502772,"exec_count":24,"id":"01ffb8","input":"def read_code(source, outputs=None):\n    \n#    out = '<sage language=\"python\">\\n'\n\n    # 7-bit C1 ANSI sequences\n    ansi_escape = re.compile(r'''\n    \\x1B    # ESC\n    [@-_]   # 7-bit C1 Fe\n    [0-?]*  # Parameter bytes\n    [ -/]*  # Intermediate bytes\n    [@-~]   # Final byte\n    ''', re.VERBOSE)\n\n    out = '<console>\\n'\n    \n    out += '<input>\\n'+''.join(source).replace('<', '&lt;')+'\\n</input>\\n'\n    \n    if outputs:\n        \n        # outputs can be a string on its own, or a list of strings for multiline display\n        \n        temp = ''\n        \n        if type(outputs)==list:\n            for p in outputs:\n                strip = ansi_escape.sub('', p)  # ocassionally Jupyter has formated the output to include ASCII control\n                                              # Characters. This snippet removes them and gives a clean string.\n                temp += strip\n        else:\n            temp = ansi_escape.sub('', outputs) # ocassionally Jupyter has formated the output to include ASCII control\n                                                # Characters. This snippet removes them and gives a clearn string.\n            \n        out += '<output>\\n'+''.join(temp).replace('<', '&lt;')+'\\n</output>\\n'\n        \n#    out += '</sage>\\n'\n    \n    out += '</console>\\n'\n    \n    return out    ","kernel":"python3","no_halt":true,"pos":23,"start":1647444502769,"state":"done","type":"cell"}
{"cell_type":"code","end":1647444502787,"exec_count":25,"id":"28278e","input":"pretext_head = '''<pretext>\n\n    <docinfo>\n        <macros>\n        \\\\newcommand{\\doubler}[1]{2#1}\n        </macros>\n    </docinfo>\n\n    <article xml:id=\"minimal\">\n        <title>Conversion Script Test</title>\n\n        <frontmatter>\n\n            <titlepage>\n                <author>\n                    <personname>Virgil U Pierce</personname>\n                    <institution>University of Northern Colorado</institution>\n                </author>\n                <date><today /></date>\n            </titlepage>\n\n            <abstract>\n                <p>Testing of conversion of a Jupyter notebook to Pretext, and compiling</p>\n            </abstract>\n            \n            <introduction>\n\n                <p>Check if process.call worked</p>\n\n                <p>This is a short paragraph to introduce the article (but it is not the abstract).  \n                It is optional, in case it would be preferable to have the first section be titled an \n                <q>Introduction.</q></p>\n            </introduction>\n            \n        </frontmatter>'''","kernel":"python3","no_halt":true,"pos":24,"start":1647444502780,"state":"done","type":"cell"}
{"cell_type":"code","end":1647444502802,"exec_count":26,"id":"d6b8ae","input":"pretext_tail = '''</article>\n</pretext>'''","kernel":"python3","no_halt":true,"pos":25,"start":1647444502793,"state":"done","type":"cell"}
{"cell_type":"code","end":1647444502818,"exec_count":27,"id":"22ae6f","input":"def add_block(cell, current):\n    \n    out = ''\n    \n    if cell['cell_type']=='markdown':\n        out, current = read_metadata(cell['source'], current)\n    elif cell['cell_type']=='code':\n        out += '<listing>\\n'\n        if cell['outputs']:\n            if 'data' in cell['outputs'][0]:\n                out += read_code(cell['source'], cell['outputs'][0]['data']['text/plain'])\n            elif 'text' in cell['outputs'][0]:\n                out += read_code(cell['source'], cell['outputs'][0]['text'])\n        else:\n            out += read_code(cell['source'])\n        out += '</listing>\\n'\n    else:\n        print('Unkown Cell Type Found')\n        \n    return out, current","kernel":"python3","no_halt":true,"pos":26,"start":1647444502810,"state":"done","type":"cell"}
{"cell_type":"code","end":1647444502846,"exec_count":28,"id":"13356f","input":"import sys\n\nsys.executable","kernel":"python3","no_halt":true,"output":{"0":{"data":{"text/plain":"'/usr/bin/python3'"},"exec_count":28}},"pos":27,"start":1647444502823,"state":"done","type":"cell"}
{"cell_type":"code","end":1647444503012,"exec_count":29,"id":"41a325","input":"current = 0\n\nout = ''\n\nfor cell in cells:\n    print('Reading Cell {}'.format(cells.index(cell)) )\n    temp, current = add_block(cell, current)\n    out += temp\n        \n# Final step for the block metadata read, close any currently open environments that have not already\n# been closed.\n    \n# However List, Enumerate, and Quote environments will be assumed to terminate within a block.\n    \nfor i in range(current, 0, -1):   \n    out += close_section(i)","kernel":"python3","no_halt":true,"output":{"0":{"name":"stdout","text":"Reading Cell 0\nReading Cell 1\nReading Cell 2\nReading Cell 3\nReading Cell 4\nReading Cell 5\nReading Cell 6\nReading Cell 7\nReading Cell 8\nReading Cell 9\nReading Cell 10\nReading Cell 11\nReading Cell 12\nReading Cell 13\nReading Cell 14\nReading Cell 15\nReading Cell 16\nReading Cell 17\nReading Cell 18\nReading Cell 19\nReading Cell 20\nReading Cell 21\nReading Cell 22\nReading Cell 23\n"},"1":{"ename":"ValueError","evalue":"substring not found","traceback":["\u001b[0;31m---------------------------------------------------------------------------\u001b[0m","\u001b[0;31mValueError\u001b[0m                                Traceback (most recent call last)","\u001b[0;32m/tmp/ipykernel_1052/3200073409.py\u001b[0m in \u001b[0;36m<module>\u001b[0;34m\u001b[0m\n\u001b[1;32m      5\u001b[0m \u001b[0;32mfor\u001b[0m \u001b[0mcell\u001b[0m \u001b[0;32min\u001b[0m \u001b[0mcells\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m      6\u001b[0m     \u001b[0mprint\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m'Reading Cell {}'\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mformat\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mcells\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mindex\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mcell\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m)\u001b[0m \u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m----> 7\u001b[0;31m     \u001b[0mtemp\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mcurrent\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0madd_block\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mcell\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mcurrent\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m      8\u001b[0m     \u001b[0mout\u001b[0m \u001b[0;34m+=\u001b[0m \u001b[0mtemp\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m      9\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n","\u001b[0;32m/tmp/ipykernel_1052/1609295652.py\u001b[0m in \u001b[0;36madd_block\u001b[0;34m(cell, current)\u001b[0m\n\u001b[1;32m      4\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m      5\u001b[0m     \u001b[0;32mif\u001b[0m \u001b[0mcell\u001b[0m\u001b[0;34m[\u001b[0m\u001b[0;34m'cell_type'\u001b[0m\u001b[0;34m]\u001b[0m\u001b[0;34m==\u001b[0m\u001b[0;34m'markdown'\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m----> 6\u001b[0;31m         \u001b[0mout\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mcurrent\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mread_metadata\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mcell\u001b[0m\u001b[0;34m[\u001b[0m\u001b[0;34m'source'\u001b[0m\u001b[0;34m]\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mcurrent\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m      7\u001b[0m     \u001b[0;32melif\u001b[0m \u001b[0mcell\u001b[0m\u001b[0;34m[\u001b[0m\u001b[0;34m'cell_type'\u001b[0m\u001b[0;34m]\u001b[0m\u001b[0;34m==\u001b[0m\u001b[0;34m'code'\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m      8\u001b[0m         \u001b[0mout\u001b[0m \u001b[0;34m+=\u001b[0m \u001b[0;34m'<listing>\\n'\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n","\u001b[0;32m/tmp/ipykernel_1052/1003076298.py\u001b[0m in \u001b[0;36mread_metadata\u001b[0;34m(cell, current)\u001b[0m\n\u001b[1;32m     14\u001b[0m             \u001b[0mout\u001b[0m \u001b[0;34m+=\u001b[0m \u001b[0mtemp\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m     15\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m---> 16\u001b[0;31m         \u001b[0mtemp\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0menvr\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mread_line\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mp\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0menvr\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m     17\u001b[0m         \u001b[0mout\u001b[0m \u001b[0;34m+=\u001b[0m \u001b[0mtemp\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m     18\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n","\u001b[0;32m/tmp/ipykernel_1052/2119899925.py\u001b[0m in \u001b[0;36mread_line\u001b[0;34m(p, envr)\u001b[0m\n\u001b[1;32m     41\u001b[0m             \u001b[0;32mif\u001b[0m \u001b[0mlen\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mp\u001b[0m\u001b[0;34m)\u001b[0m \u001b[0;34m>\u001b[0m \u001b[0;36m0\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m     42\u001b[0m                 \u001b[0;32mif\u001b[0m \u001b[0mp\u001b[0m\u001b[0;34m[\u001b[0m\u001b[0;36m0\u001b[0m\u001b[0;34m]\u001b[0m\u001b[0;34m==\u001b[0m\u001b[0;34m'['\u001b[0m \u001b[0;32mand\u001b[0m \u001b[0;34m']'\u001b[0m \u001b[0;32min\u001b[0m \u001b[0mp\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m---> 43\u001b[0;31m                     \u001b[0mtemp\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mp\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mrender_link\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mp\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m     44\u001b[0m                     \u001b[0mout\u001b[0m \u001b[0;34m+=\u001b[0m \u001b[0mtemp\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m     45\u001b[0m                 \u001b[0;32melif\u001b[0m \u001b[0mp\u001b[0m\u001b[0;34m[\u001b[0m\u001b[0;36m0\u001b[0m\u001b[0;34m]\u001b[0m\u001b[0;34m==\u001b[0m\u001b[0;34m'*'\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n","\u001b[0;32m/tmp/ipykernel_1052/1943906581.py\u001b[0m in \u001b[0;36mrender_link\u001b[0;34m(p)\u001b[0m\n\u001b[1;32m      4\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m      5\u001b[0m     \u001b[0mend1\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mp\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mindex\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m']'\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m----> 6\u001b[0;31m     \u001b[0mend2\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mp\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mindex\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m')'\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m      7\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m      8\u001b[0m     \u001b[0mtext\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mp\u001b[0m\u001b[0;34m[\u001b[0m\u001b[0;36m1\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0mend1\u001b[0m\u001b[0;34m]\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n","\u001b[0;31mValueError\u001b[0m: substring not found"]}},"pos":28,"start":1647444502866,"state":"done","type":"cell"}
{"cell_type":"code","end":1647444503030,"exec_count":30,"id":"ace0e8","input":"pretext = pretext_head + out + pretext_tail","kernel":"python3","no_halt":true,"pos":29,"start":1647444503024,"state":"done","type":"cell"}
{"cell_type":"code","end":1647444503051,"exec_count":31,"id":"0ded14","input":"text_file = open('test.xml', \"w\")\n\ntext_file.write(pretext)\n\ntext_file.close()","kernel":"python3","no_halt":true,"pos":30,"start":1647444503038,"state":"done","type":"cell"}
{"cell_type":"code","end":1647444503145,"exec_count":32,"id":"e20a97","input":"%%bash\nxsltproc ../mathbook/xsl/mathbook-html.xsl test.xml","kernel":"python3","no_halt":true,"output":{"0":{"name":"stderr","text":"warning: failed to load external entity \"../mathbook/xsl/mathbook-html.xsl\"\ncannot parse ../mathbook/xsl/mathbook-html.xsl\n"},"1":{"ename":"CalledProcessError","evalue":"Command 'b'xsltproc ../mathbook/xsl/mathbook-html.xsl test.xml\\n'' returned non-zero exit status 4.","traceback":["\u001b[0;31m---------------------------------------------------------------------------\u001b[0m","\u001b[0;31mCalledProcessError\u001b[0m                        Traceback (most recent call last)","\u001b[0;32m/tmp/ipykernel_1052/3051596741.py\u001b[0m in \u001b[0;36m<module>\u001b[0;34m\u001b[0m\n\u001b[0;32m----> 1\u001b[0;31m \u001b[0mget_ipython\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mrun_cell_magic\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m'bash'\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0;34m''\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0;34m'xsltproc ../mathbook/xsl/mathbook-html.xsl test.xml\\n'\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m","\u001b[0;32m/usr/local/lib/python3.8/dist-packages/IPython/core/interactiveshell.py\u001b[0m in \u001b[0;36mrun_cell_magic\u001b[0;34m(self, magic_name, line, cell)\u001b[0m\n\u001b[1;32m   2417\u001b[0m             \u001b[0;32mwith\u001b[0m \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mbuiltin_trap\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m   2418\u001b[0m                 \u001b[0margs\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0;34m(\u001b[0m\u001b[0mmagic_arg_s\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mcell\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m-> 2419\u001b[0;31m                 \u001b[0mresult\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mfn\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m*\u001b[0m\u001b[0margs\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0;34m**\u001b[0m\u001b[0mkwargs\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m   2420\u001b[0m             \u001b[0;32mreturn\u001b[0m \u001b[0mresult\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m   2421\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n","\u001b[0;32m/usr/local/lib/python3.8/dist-packages/IPython/core/magics/script.py\u001b[0m in \u001b[0;36mnamed_script_magic\u001b[0;34m(line, cell)\u001b[0m\n\u001b[1;32m    140\u001b[0m             \u001b[0;32melse\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    141\u001b[0m                 \u001b[0mline\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mscript\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m--> 142\u001b[0;31m             \u001b[0;32mreturn\u001b[0m \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mshebang\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mline\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mcell\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m    143\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    144\u001b[0m         \u001b[0;31m# write a basic docstring:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n","\u001b[0;32m<decorator-gen-103>\u001b[0m in \u001b[0;36mshebang\u001b[0;34m(self, line, cell)\u001b[0m\n","\u001b[0;32m/usr/local/lib/python3.8/dist-packages/IPython/core/magic.py\u001b[0m in \u001b[0;36m<lambda>\u001b[0;34m(f, *a, **k)\u001b[0m\n\u001b[1;32m    185\u001b[0m     \u001b[0;31m# but it's overkill for just that one bit of state.\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    186\u001b[0m     \u001b[0;32mdef\u001b[0m \u001b[0mmagic_deco\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0marg\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m--> 187\u001b[0;31m         \u001b[0mcall\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0;32mlambda\u001b[0m \u001b[0mf\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0;34m*\u001b[0m\u001b[0ma\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0;34m**\u001b[0m\u001b[0mk\u001b[0m\u001b[0;34m:\u001b[0m \u001b[0mf\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m*\u001b[0m\u001b[0ma\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0;34m**\u001b[0m\u001b[0mk\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m    188\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    189\u001b[0m         \u001b[0;32mif\u001b[0m \u001b[0mcallable\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0marg\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n","\u001b[0;32m/usr/local/lib/python3.8/dist-packages/IPython/core/magics/script.py\u001b[0m in \u001b[0;36mshebang\u001b[0;34m(self, line, cell)\u001b[0m\n\u001b[1;32m    243\u001b[0m             \u001b[0msys\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mstderr\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mflush\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    244\u001b[0m         \u001b[0;32mif\u001b[0m \u001b[0margs\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mraise_error\u001b[0m \u001b[0;32mand\u001b[0m \u001b[0mp\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mreturncode\u001b[0m\u001b[0;34m!=\u001b[0m\u001b[0;36m0\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m--> 245\u001b[0;31m             \u001b[0;32mraise\u001b[0m \u001b[0mCalledProcessError\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mp\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mreturncode\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mcell\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0moutput\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0mout\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mstderr\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0merr\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m    246\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    247\u001b[0m     \u001b[0;32mdef\u001b[0m \u001b[0m_run_script\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mself\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mp\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mcell\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mto_close\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n","\u001b[0;31mCalledProcessError\u001b[0m: Command 'b'xsltproc ../mathbook/xsl/mathbook-html.xsl test.xml\\n'' returned non-zero exit status 4."]}},"pos":31,"start":1647444503070,"state":"done","type":"cell"}
{"cell_type":"code","id":"4ad71e","input":"","pos":32,"type":"cell"}
{"id":0,"time":1648569115048,"type":"user"}
{"last_load":1647444424417,"type":"file"}