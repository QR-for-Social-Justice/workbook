<!DOCTYPE html>
<html lang="en-US">
<!--********************************************-->
<!--*       Generated from PreTeXt source      *-->
<!--*                                          *-->
<!--*         https://pretextbook.org          *-->
<!--*                                          *-->
<!--********************************************-->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="robots" content="noindex, nofollow">
</head>
<body class="ignore-math">
<h3 class="heading"><span class="type">Paragraph</span></h3>
<div class="para logical"><ol class="decimal">
<li><div class="para"><em class="emphasis">At this point, it is useful for students to make themselves a “cheat sheet” which tells them the multiplicative inverse of any number mod 26, if it exists. (My expectation is not that they memorize such a list, though more power to them if they’d like to!) At this point, the most likely strategy students will use to find <span class="process-math">\(m^{-1}\mod26\)</span> is trial and error: multiplying each <span class="process-math">\(m\)</span> by various integers mod <span class="process-math">\(26\)</span> until they end up with <span class="process-math">\(1\mod26\text{.}\)</span> The number they multiplied by to get <span class="process-math">\(1\)</span> is their <span class="process-math">\(m^{-1}\text{,}\)</span> if such a number exists. Ask: what relationship between <span class="process-math">\(m\)</span> and the modulus <span class="process-math">\(26\)</span> predicts whether <span class="process-math">\(m^{-1}\)</span> exists?</em></div></li>
<li>
<div class="para"><em class="emphasis">In an introduction to proof or number theory class, this would be an excellent time to prompt students to prove that <span class="process-math">\(m^{-1}\)</span> exists modulo <span class="process-math">\(n\)</span> if and only if <span class="process-math">\(\gcd(m,n)=1\text{.}\)</span> Prompt them to think about their multiplication tables and the fact that every integer modulo <span class="process-math">\(n\)</span> appears in the <span class="process-math">\(m\)</span>th row precisely when <span class="process-math">\(m\)</span> and <span class="process-math">\(n\)</span> are relatively prime. In fact, students can prove that</em></div>
<div class="para"><em class="emphasis"><dfn class="terminology">7</dfn>.  <em class="emphasis">If <span class="process-math">\(m\)</span> is a whole number between <span class="process-math">\(0\)</span> and <span class="process-math">\(n-1\text{,}\)</span> then <span class="process-math">\(\gcd(m,n)\)</span> divides any number that’s congruent to <span class="process-math">\(m\mod n\text{.}\)</span></em></em></div>
<div class="para"><em class="emphasis">One prompt to lead students toward the general proof is the following specific example: assume some number <span class="process-math">\(x\)</span> is congruent to <span class="process-math">\(m=4\mod12\text{.}\)</span> Then <span class="process-math">\(x/12=yR4\)</span> (here <span class="process-math">\(R\)</span> denotes “remainder” in language that should be familiar to students), where <span class="process-math">\(y\)</span> is some whole number. So <span class="process-math">\(x\)</span> is some multiple of <span class="process-math">\(12\)</span> plus <span class="process-math">\(4\text{;}\)</span> we can write <span class="process-math">\(x=12y+4\text{,}\)</span> where <span class="process-math">\(y\)</span> is some whole number. Now, <span class="process-math">\(\gcd(4,12)=4\)</span> and <span class="process-math">\(x=4(3y+1)\)</span> is divisible by <span class="process-math">\(4\text{.}\)</span></em></div>
</li>
<li><div class="para"><em class="emphasis">At this point, students have the cheat sheet and tools necessary to decrypt affine ciphers with known key. Have them try decrypting some example ciphertext under various affine ciphers. Naturally, students may at first be most comfortable only doing arithmetic modulo <span class="process-math">\(26\text{,}\)</span> but it takes surprisingly little in my experience to prompt them to consider other moduli. Students may try decrypting affine ciphers in different alphabets at this stage: for example, decrypt <span class="process-math">\(c\equiv7p\mod29\)</span> using the lowercase English alphabet with !?, appended. We need to multiply both sides by some number <span class="process-math">\(x\)</span> so that <span class="process-math">\(7x\equiv1\mod29\text{.}\)</span> How do we systematically find <span class="process-math">\(x\text{?}\)</span> This is a great time for an optional detour into the extended Euclidean algorithm; students without much previous college-level math experience often find this difficult, so it may be skipped without losing the thread of this activity.</em></div></li>
<li>
<div class="para"><em class="emphasis">Students in a proof-based course may now attempt to prove the following corollary of Proposition <code class="code-inline tex2jax_ignore">[cross-reference to target(s) "KI-prop:gcd(m, n)-divides-mk" missing or not unique]</code>.</em></div>
<div class="para"><em class="emphasis"><dfn class="terminology">8</dfn>.  <em class="emphasis">If <span class="process-math">\(\gcd(m,n)\neq1\text{,}\)</span> then no multiple of <span class="process-math">\(m\)</span> is congruent to <span class="process-math">\(1\mod n\text{.}\)</span> In other words, we can’t get every number in row <span class="process-math">\(m\)</span> of the <span class="process-math">\(\mod n\)</span> multiplication table, and <em class="emphasis"><span class="process-math">\(m\)</span></em> does not have a multiplicative inverse <em class="emphasis"><span class="process-math">\(\mod n\text{.}\)</span></em> In fact, the following are equivalent for any whole numbers <span class="process-math">\(m,n\text{:}\)</span></em></em></div>
<div class="para logical"><ol class="lower-alpha">
<li><div class="para"><em class="emphasis"><em class="emphasis"><span class="process-math">\(\gcd(m,n)=1\text{.}\)</span></em></em></div></li>
<li><div class="para"><em class="emphasis"><em class="emphasis">any affine cipher with multiplicative key <span class="process-math">\(m\mod n\)</span> is decryptable by the intended recipient.</em></em></div></li>
<li><div class="para"><em class="emphasis"><em class="emphasis">every number between <span class="process-math">\(0\)</span> and <span class="process-math">\(n-1\)</span> is a multiple of <span class="process-math">\(m\mod n\text{.}\)</span></em></em></div></li>
<li><div class="para"><em class="emphasis"><em class="emphasis"><span class="process-math">\(m\)</span> has a multiplicative inverse <span class="process-math">\(m^{-1}\mod n\text{.}\)</span></em></em></div></li>
</ol></div>
<div class="para"><em class="emphasis">An example that may lead students toward part of the proof: consider the affine cipher <span class="process-math">\(c\equiv13p\mod26\text{.}\)</span> Note that <span class="process-math">\(\gcd(13,26)=13\text{.}\)</span> Any plaintext letter that we plug in will spit out some multiple of <span class="process-math">\(13\text{.}\)</span> Reduced mod <span class="process-math">\(26\text{,}\)</span> these multiples of <span class="process-math">\(13\)</span> all become either <span class="process-math">\(13\)</span> or <span class="process-math">\(0\text{.}\)</span> And <span class="process-math">\(\gcd(13,26)=13\)</span> divides both <span class="process-math">\(13\)</span> and <span class="process-math">\(0\)</span> evenly. Since no multiple of <span class="process-math">\(13\)</span> can be congruent to <span class="process-math">\(1\mod26\text{,}\)</span> <span class="process-math">\(13\)</span> does not have a multiplicative inverse modulo <span class="process-math">\(26\text{.}\)</span></em></div>
</li>
<li><div class="para"><em class="emphasis">Now, prompt students to consider how important it is before decrypting an affine cipher to verify that <span class="process-math">\(\gcd(m,n)=1\text{.}\)</span> Given a cipher like <span class="process-math">\(c\equiv137p+538\mod341319\text{,}\)</span> how could students determine whether the cipher was monoalphabetic, and hence whether our techniques will decrypt it?</em></div></li>
<li><div class="para"><em class="emphasis">Computers can only understand numbers (which are written in <span class="process-math">\(0\)</span>s and <span class="process-math">\(1\)</span>s), not letters. The computer language ASCII represents all commonly-used written characters as numbers between <span class="process-math">\(1\)</span> and <span class="process-math">\(256\text{.}\)</span> Do you think we can encrypt ASCII messages using the affine cipher <span class="process-math">\(C\equiv8P\mod256\text{?}\)</span> Why or why not? What multiplicative keys can be used in a monoalphabetic, affine ASCII cipher?</em></div></li>
</ol></div>
<span class="incontext"><a href="onramp-to-number-theory.html#p-260" class="internal">in-context</a></span>
</body>
</html>
